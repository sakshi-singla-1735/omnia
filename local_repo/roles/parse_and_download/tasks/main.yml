# Copyright 2025 Dell Inc. or its subsidiaries. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
---

- name: Define project input path
  ansible.builtin.set_fact:
    project_input_path: "{{ hostvars['localhost']['input_project_dir'] }}"
    update_metadata: false
    show_softwares_status: false

- name: Include oim metadata vars
  ansible.builtin.include_vars: "{{ omnia_metadata_file }}"
  no_log: true

- name: Process and configure local_repo_config
  ansible.builtin.include_tasks: process_rpm_repo.yml

- name: Encrypt user certificates if exist
  cert_vault_handler:
    mode: encrypt
    log_dir: "{{ base_path }}"
    key_path: "{{ project_input_path }}"
  register: vault_result

- name: Execute tasks for each architecture
  ansible.builtin.include_tasks: arch_component_loop.yml
  no_log: true
  loop: "{{ result.software_dict | dict2items }}"
  loop_control:
    loop_var: arch_item
  vars:
    components: "{{ arch_item.value | dict2items }}"

# to be removed later
- name: Load software_config.json
  ansible.builtin.include_vars:
    file: "/opt/omnia/input/project_default/software_config.json"
    name: software_config

- name: Generate software JSON file names
  ansible.builtin.set_fact:
    software_names: "{{ software_config.softwares | map(attribute='name') | select('defined') | list }}"

- name: Create a dictionary of software architectures
  ansible.builtin.set_fact:
    fetch_arch: "{{ software_config.softwares | items2dict(key_name='name', value_name='arch') }}"

- name: Combine all architectures into a single list
  ansible.builtin.set_fact:
    all_archs: >-
      {{
        fetch_arch.values()
        | select('defined')
        | flatten
        | unique
      }}

- name: Set fact for all_archs_var
  ansible.builtin.set_fact:
    all_archs_var: "{{ hostvars['localhost']['all_archs'] }}"

- name: Clear the rpm downloaded files for each arch
  ansible.builtin.file:
    path: "{{ rpm_dir_path }}"
    state: absent
  loop: "{{ all_archs_var }}"
  when: clean_rpms

- name: Create folder {{ provision_shared_path }}
  ansible.builtin.file:
    path: "{{ provision_shared_path }}"
    state: directory
    mode: "{{ folder_mode }}"

- name: Create local_repo_access.yml file
  ansible.builtin.template:
    src: "{{ local_repo_access_src_path }}"
    dest: "{{ local_repo_access_dest_path }}"
    mode: "{{ file_mode }}"

- name: Determine final repository status
  ansible.builtin.set_fact:
    final_status: >-
      {{
        'FAILED' if
        (
          overall_status_dict | default({}) | dict2items |
          map(attribute='value') |
          sum(start=[]) |
          map(attribute='overall_status') |
          select('in', ['FAILURE', 'TIMEOUT', 'PARTIAL']) |
          list |
          length > 0
        )
        else 'SUCCESS'
      }}

- name: Check if metadata file exists
  ansible.builtin.stat:
    path: "{{ metadata_file_path }}"
  register: metadata_file

- name: Set update metadata flag
  ansible.builtin.set_fact:
    update_metadata: "{{ true | bool }}"
  when:
    - metadata_file.stat.exists
    - final_status == 'SUCCESS'

- name: Persist local repoitory information into metadata file localrepo_metadata.yml
  localrepo_metadata_manager:
    software_config_path: "{{ sw_config_json_path }}"
    localrepo_config_path: "{{ local_repo_config_path }}"
    output_file: "{{ metadata_file_path }}"
    update_metadata: "{{ update_metadata }}"
  register: policy_result
  when:
    - final_status == 'SUCCESS'

- name: Show updated keys
  ansible.builtin.debug:
    var: policy_result.diff
  when: update_metadata

- name: Run custom parallel task to print overall software status
  parallel_tasks:
    tasks: []
    software: []
    local_repo_config_path: "{{ local_repo_config_path }}"
    overall_status_dict: "{{ overall_status_dict }}"
    show_softwares_status: "{{ true | bool }}"
  register: status_results
  when: overall_status_dict is defined and overall_status_dict | length > 0

- name: Print overall software status
  ansible.builtin.debug:
    msg: "{{ status_results.msg.split('\n') if status_results.msg is defined else sw_download_msg }}"

- name: Display total playbook execution time in minutes and seconds
  ansible.builtin.debug:
    msg: >
      Total playbook execution time: {{
        ((lookup('pipe', 'date +%s') | int - playbook_start_time | int) // 60)
      }} min and {{
        ((lookup('pipe', 'date +%s') | int - playbook_start_time | int) % 60)
      }} sec

- name: Local repository status
  ansible.builtin.debug:
    msg: "{{ 'localrepository SUCCESS' if final_status == 'SUCCESS' else 'Local repo setup failed — some packages didn’t download, and dependent scripts/playbooks may also fail. Refer to the localrepo logs for more details. Rerun local_repo.yml.' }}" # noqa: yaml[line-length]
  failed_when: final_status != 'SUCCESS'
